"""
UAVCrew MCP Gateway CLI

Interactive setup wizard and configuration tools.

Usage:
    uavcrew status             # Check status, manifest, and service
    uavcrew setup              # Interactive configuration wizard
    uavcrew start              # Start the MCP Gateway service
    uavcrew stop               # Stop the MCP Gateway service
    uavcrew restart            # Restart the MCP Gateway service
    uavcrew keys list          # Show configured API keys
    uavcrew keys add <token>   # Add an API key
    uavcrew keys remove <key>  # Remove an API key
    uavcrew generate-systemd   # Generate systemd unit file
"""

import os
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional

import typer
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Confirm, Prompt
from rich.table import Table

app = typer.Typer(
    name="uavcrew",
    help="UAVCrew MCP Gateway configuration and management tools.",
    no_args_is_help=True,
)
console = Console()


def load_env_file(path: Path) -> dict:
    """Load environment variables from .env file."""
    env = {}
    if path.exists():
        with open(path) as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, _, value = line.partition("=")
                    env[key.strip()] = value.strip()
    return env


def write_env_file(path: Path, config: dict) -> None:
    """Write configuration to .env file, preserving existing values not in config."""
    # Read existing file to preserve extra variables
    existing_lines = []
    existing_keys = set()
    if path.exists():
        with open(path) as f:
            existing_lines = f.readlines()
        for line in existing_lines:
            stripped = line.strip()
            if stripped and not stripped.startswith("#") and "=" in stripped:
                key = stripped.split("=", 1)[0].strip()
                existing_keys.add(key)

    # Keys managed by the setup wizard
    managed_keys = set(config.keys())

    # Rewrite: update managed keys in-place, keep everything else
    new_lines = []
    written_keys = set()

    for line in existing_lines:
        stripped = line.strip()
        if stripped and not stripped.startswith("#") and "=" in stripped:
            key = stripped.split("=", 1)[0].strip()
            if key in managed_keys:
                new_lines.append(f"{key}={config[key]}\n")
                written_keys.add(key)
            else:
                # Preserve unmanaged keys as-is
                new_lines.append(line if line.endswith("\n") else line + "\n")
        else:
            new_lines.append(line if line.endswith("\n") else line + "\n")

    # Append any managed keys not already in the file
    missing = managed_keys - written_keys
    if missing:
        new_lines.append("\n")
        for key in sorted(missing):
            new_lines.append(f"{key}={config[key]}\n")

    # If no existing file, write a fresh template
    if not existing_lines:
        new_lines = [
            "# UAVCrew MCP Gateway Configuration\n",
            "# Generated by: uavcrew setup\n",
            "\n",
        ]
        for key in sorted(config.keys()):
            new_lines.append(f"{key}={config[key]}\n")

    with open(path, "w") as f:
        f.writelines(new_lines)


def detect_paths() -> dict:
    """Detect virtualenv, working directory, and user."""
    in_venv = sys.prefix != sys.base_prefix

    if in_venv:
        # Use the venv python directly — do NOT resolve() as that follows
        # symlinks to the system python, which won't have our packages.
        python = Path(sys.prefix) / "bin" / Path(sys.executable).name
    else:
        python = Path(sys.executable)

    return {
        "workdir": Path.cwd().resolve(),
        "venv": Path(sys.prefix) if in_venv else None,
        "python": python,
        "user": os.environ.get("USER", "root"),
    }


LOG_DIR = "/var/log/ayna/mcp-gateway"


def generate_systemd_unit(paths: dict, env_path: Path) -> str:
    """Generate systemd unit file content."""
    venv_bin = f"{paths['venv']}/bin" if paths["venv"] else "/usr/local/bin"
    gunicorn = f"{venv_bin}/gunicorn"
    config_path = f"{paths['workdir']}/gunicorn_config.py"

    return f"""[Unit]
Description=UAVCrew MCP Gateway
Documentation=https://docs.uavcrew.ai/mcp
After=network.target

[Service]
Type=notify
User={paths['user']}
Group={paths['user']}
WorkingDirectory={paths['workdir']}
EnvironmentFile={env_path.resolve()}
Environment="PATH={venv_bin}"
ExecStart={gunicorn} \\
    --config {config_path} \\
    mcp_server.server:app
ExecReload=/bin/kill -s HUP $MAINPID
Restart=on-failure
RestartSec=5
KillMode=mixed
TimeoutStopSec=30

# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths={paths['workdir']} {LOG_DIR}

[Install]
WantedBy=multi-user.target
"""


def generate_caddy_config(domain: str) -> str:
    """Generate Caddyfile configuration."""
    return f"""{domain} {{
    reverse_proxy localhost:8200
}}
"""


def generate_nginx_config(domain: str) -> str:
    """Generate nginx configuration."""
    return f"""server {{
    listen 80;
    server_name {domain};
    return 301 https://$server_name$request_uri;
}}

server {{
    listen 443 ssl http2;
    server_name {domain};

    # SSL certificates - update paths after running certbot
    ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;

    # Security headers
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options DENY;

    location / {{
        proxy_pass http://127.0.0.1:8200;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
"""


def generate_apache_config(domain: str) -> str:
    """Generate Apache configuration."""
    return f"""<VirtualHost *:80>
    ServerName {domain}
    Redirect permanent / https://{domain}/
</VirtualHost>

<VirtualHost *:443>
    ServerName {domain}

    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/{domain}/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/{domain}/privkey.pem

    ProxyPreserveHost On
    ProxyPass / http://127.0.0.1:8200/
    ProxyPassReverse / http://127.0.0.1:8200/

    <Location />
        Require all granted
    </Location>
</VirtualHost>
"""


# =============================================================================
# Status Command
# =============================================================================

SERVICE_NAME = "mcp-server"


def _check_systemd_service() -> dict:
    """Check systemd service status. Returns dict with status info."""
    result = {
        "installed": False,
        "enabled": False,
        "running": False,
        "status": "not installed",
    }

    service_file = Path(f"/etc/systemd/system/{SERVICE_NAME}.service")
    if not service_file.exists():
        return result

    result["installed"] = True

    # Check if enabled
    try:
        proc = subprocess.run(
            ["systemctl", "is-enabled", SERVICE_NAME],
            capture_output=True,
            text=True,
        )
        result["enabled"] = proc.returncode == 0
    except Exception:
        pass

    # Check if running
    try:
        proc = subprocess.run(
            ["systemctl", "is-active", SERVICE_NAME],
            capture_output=True,
            text=True,
        )
        result["running"] = proc.stdout.strip() == "active"
        result["status"] = proc.stdout.strip()
    except Exception:
        pass

    return result


def _check_process_running(port: int = 8200) -> dict:
    """Check if MCP gateway process is running (non-systemd)."""
    result = {
        "running": False,
        "pid": None,
        "workers": 0,
        "method": None,
    }

    try:
        # Check if something is listening on the port
        proc = subprocess.run(
            ["ss", "-tlnp", f"sport = :{port}"],
            capture_output=True,
            text=True,
        )
        if f":{port}" in proc.stdout:
            result["running"] = True
            import re
            match = re.search(r'pid=(\d+)', proc.stdout)
            if match:
                result["pid"] = match.group(1)
            result["method"] = "manual"

            # Count gunicorn workers
            try:
                worker_proc = subprocess.run(
                    ["pgrep", "-c", "-P", result["pid"] or "0"],
                    capture_output=True,
                    text=True,
                )
                if worker_proc.returncode == 0:
                    result["workers"] = int(worker_proc.stdout.strip())
            except Exception:
                pass
    except Exception:
        pass

    return result


def _check_manifest() -> dict:
    """Load and validate manifest, return status info."""
    result = {
        "loaded": False,
        "path": None,
        "entity_count": 0,
        "action_count": 0,
        "entities": [],
        "errors": [],
    }

    manifest_path = os.environ.get("MCP_MANIFEST_PATH", "./manifest.json")
    result["path"] = manifest_path

    if not Path(manifest_path).exists():
        result["errors"].append(f"Manifest file not found: {manifest_path}")
        return result

    try:
        from .manifest import load_manifest, get_entity_names, get_entity_actions

        manifest = load_manifest(manifest_path)
        result["loaded"] = True

        entity_names = get_entity_names(manifest)
        result["entity_count"] = len(entity_names)
        result["entities"] = list(entity_names)

        # Count total actions across all entities
        total_actions = 0
        for name in entity_names:
            actions = get_entity_actions(manifest, name)
            if actions:
                total_actions += len(actions)
        result["action_count"] = total_actions

    except Exception as e:
        result["errors"].append(str(e))

    return result


@app.command()
def status():
    """Check MCP gateway status, configuration, and manifest."""
    from . import __version__
    console.print(
        Panel.fit(
            f"[bold blue]UAVCrew MCP Gateway[/bold blue] [dim]v{__version__}[/dim]",
            border_style="blue",
        )
    )

    env_path = Path.cwd() / ".env"
    all_ok = True

    # ==========================================================================
    # Configuration
    # ==========================================================================
    console.print("\n[bold]Configuration:[/bold]")

    port = 8200

    if env_path.exists():
        console.print("  [green]\u2713[/green] .env file exists")
        env_vars = load_env_file(env_path)

        # Load env vars so manifest loader can find MCP_MANIFEST_PATH
        from dotenv import load_dotenv
        load_dotenv(env_path)

        # Check API keys
        api_key = env_vars.get("MCP_API_KEY", "")
        api_keys = env_vars.get("MCP_API_KEYS", "")
        if api_key or api_keys:
            key_count = len([k for k in (api_key + "," + api_keys).split(",") if k.strip()])
            console.print(f"  [green]\u2713[/green] API key(s) configured ({key_count} key(s))")
        else:
            console.print("  [yellow]![/yellow] No API keys configured (server will be open)")

        # Check auth mode from manifest
        manifest_path = os.environ.get("MCP_MANIFEST_PATH", env_vars.get("MCP_MANIFEST_PATH", "./manifest.json"))
        try:
            import json
            with open(manifest_path) as _mf:
                _manifest_data = json.load(_mf)
            auth = _manifest_data.get("auth", {})
            mode = auth.get("mode", "static")
            if mode == "static":
                token_env = auth.get("token_env", "CLIENT_API_TOKEN")
                has_token = bool(os.environ.get(token_env, env_vars.get(token_env, "")).strip())
                if has_token:
                    console.print(f"  [green]\u2713[/green] Token resolution: static ({token_env} configured)")
                else:
                    console.print(f"  [yellow]![/yellow] Token resolution: static ({token_env} not set)")
            elif mode == "dynamic":
                resolver_path = auth.get("resolver_path", "")
                console.print(f"  [green]\u2713[/green] Token resolution: dynamic (resolver: {resolver_path})")
        except Exception:
            console.print("  [dim]-[/dim] Token resolution: unknown (could not read manifest)")

        port = int(env_vars.get("MCP_PORT", "8200"))
        public_url = env_vars.get("MCP_PUBLIC_URL", "")
        if public_url:
            console.print(f"  [dim]Public URL: {public_url}[/dim]")
    else:
        console.print("  [red]\u2717[/red] .env file not found")
        console.print("  [dim]Run 'uavcrew setup' to configure[/dim]")
        all_ok = False

    # ==========================================================================
    # Manifest
    # ==========================================================================
    console.print("\n[bold]Manifest:[/bold]")

    manifest_info = _check_manifest()

    if manifest_info["errors"]:
        for err in manifest_info["errors"]:
            console.print(f"  [red]\u2717[/red] {err}")
        all_ok = False
    elif manifest_info["loaded"]:
        console.print(f"  [green]\u2713[/green] Loaded from {manifest_info['path']}")
        console.print(f"  [green]\u2713[/green] Entities: {manifest_info['entity_count']}")
        console.print(f"  [green]\u2713[/green] Actions: {manifest_info['action_count']}")

        # Show entity table
        table = Table(show_header=True, header_style="bold", box=None, padding=(0, 2))
        table.add_column("Entity", style="cyan")
        table.add_column("Actions", style="dim")

        from .manifest import load_manifest, get_entity, get_entity_actions
        try:
            manifest = load_manifest(manifest_info["path"])
            for name in manifest_info["entities"]:
                entity_def = get_entity(manifest, name)
                actions = get_entity_actions(manifest, name)
                action_names = ", ".join(actions.keys()) if actions else "read-only"
                table.add_row(name, action_names)
            console.print(table)
        except Exception:
            pass

    # ==========================================================================
    # Tools
    # ==========================================================================
    console.print("\n[bold]Tools:[/bold]")
    console.print("  get_entity, list_entities, search, action")

    # ==========================================================================
    # Service Status
    # ==========================================================================
    console.print("\n[bold]Service:[/bold]")

    systemd = _check_systemd_service()
    process = _check_process_running(port)

    running = False
    restart_cmd = None

    if systemd["installed"]:
        console.print("  [green]\u2713[/green] Systemd service installed")

        if systemd["enabled"]:
            console.print("  [green]\u2713[/green] Service enabled (starts on boot)")
        else:
            console.print("  [yellow]![/yellow] Service not enabled")

        if systemd["running"]:
            console.print("  [green]\u2713[/green] Service running (gunicorn)")
            running = True
            restart_cmd = f"sudo systemctl restart {SERVICE_NAME}"
            if process["workers"]:
                console.print(f"  [green]\u2713[/green] Workers: {process['workers']}")
        else:
            console.print(f"  [red]\u2717[/red] Service not running ({systemd['status']})")
            restart_cmd = f"sudo systemctl start {SERVICE_NAME}"
            all_ok = False
    else:
        console.print("  [dim]\u2013[/dim] Systemd service not installed")

        if process["running"]:
            pid_info = f"PID: {process['pid'] or 'unknown'}"
            worker_info = f", {process['workers']} workers" if process["workers"] else ""
            console.print(f"  [green]\u2713[/green] Server running (manual, {pid_info}{worker_info})")
            running = True
            restart_cmd = f"# Kill PID {process['pid']} and restart manually"
        else:
            console.print("  [red]\u2717[/red] Server not running")
            all_ok = False

    # ==========================================================================
    # Summary
    # ==========================================================================
    if all_ok:
        console.print("\n[bold green]All checks passed![/bold green]")
    else:
        console.print("\n[bold red]Some checks failed.[/bold red]")

    if not env_path.exists():
        console.print(f"  \u2192 Run [cyan]uavcrew setup[/cyan] to configure")
    elif not systemd["installed"] and not running:
        console.print(f"  \u2192 Run [cyan]uavcrew generate-systemd[/cyan] to create service")
    elif not running and restart_cmd:
        console.print(f"  \u2192 Start: [cyan]{restart_cmd}[/cyan]")


# =============================================================================
# Service Lifecycle: start, stop, restart
# =============================================================================


def _get_port() -> int:
    """Read MCP_PORT from .env or return default."""
    env_path = Path.cwd() / ".env"
    if env_path.exists():
        env_vars = load_env_file(env_path)
        return int(env_vars.get("MCP_PORT", "8200"))
    return 8200


def _wait_healthy(port: int, timeout: int = 5) -> dict | None:
    """Poll health endpoint until healthy or timeout."""
    import json
    import urllib.error
    import urllib.request

    url = f"http://localhost:{port}/health"
    deadline = time.time() + timeout
    while time.time() < deadline:
        try:
            with urllib.request.urlopen(url, timeout=2) as resp:
                return json.loads(resp.read())
        except (urllib.error.URLError, OSError):
            time.sleep(0.5)
    return None


def _require_service_installed() -> dict:
    """Check systemd service is installed, exit with message if not."""
    svc = _check_systemd_service()
    if not svc["installed"]:
        console.print("[red]Systemd service not installed.[/red]")
        console.print("Run [cyan]uavcrew setup[/cyan] or [cyan]uavcrew generate-systemd[/cyan] first.")
        raise typer.Exit(1)
    return svc


@app.command()
def start():
    """Start the MCP Gateway service."""
    svc = _require_service_installed()

    if svc["running"]:
        port = _get_port()
        process = _check_process_running(port)
        worker_info = f" ({process['workers']} workers)" if process["workers"] else ""
        console.print(f"[green]Service is already running{worker_info}.[/green]")
        return

    console.print("Starting MCP Gateway...")
    try:
        subprocess.run(
            ["sudo", "systemctl", "start", SERVICE_NAME],
            check=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError as e:
        console.print(f"[red]Failed to start service.[/red]")
        console.print(f"Check logs: [cyan]sudo journalctl -u {SERVICE_NAME} --no-pager -n 20[/cyan]")
        raise typer.Exit(1)

    port = _get_port()
    health = _wait_healthy(port)
    if health:
        process = _check_process_running(port)
        worker_info = f", {process['workers']} workers" if process["workers"] else ""
        console.print(
            f"[green]\u2713[/green] MCP Gateway running "
            f"({health.get('entities', '?')} entities{worker_info})"
        )
    else:
        console.print("[yellow]Service started but health check not responding yet.[/yellow]")
        console.print(f"Check logs: [cyan]sudo journalctl -u {SERVICE_NAME} --no-pager -n 20[/cyan]")


@app.command()
def stop():
    """Stop the MCP Gateway service."""
    svc = _require_service_installed()

    if not svc["running"]:
        console.print("[yellow]Service is already stopped.[/yellow]")
        return

    console.print("Stopping MCP Gateway...")
    try:
        subprocess.run(
            ["sudo", "systemctl", "stop", SERVICE_NAME],
            check=True,
            capture_output=True,
        )
        console.print(f"[green]\u2713[/green] Service stopped.")
    except subprocess.CalledProcessError:
        console.print("[red]Failed to stop service.[/red]")
        raise typer.Exit(1)


@app.command()
def restart():
    """Restart the MCP Gateway service."""
    svc = _require_service_installed()

    console.print("Restarting MCP Gateway...")
    try:
        subprocess.run(
            ["sudo", "systemctl", "restart", SERVICE_NAME],
            check=True,
            capture_output=True,
        )
    except subprocess.CalledProcessError:
        console.print("[red]Failed to restart service.[/red]")
        console.print(f"Check logs: [cyan]sudo journalctl -u {SERVICE_NAME} --no-pager -n 20[/cyan]")
        raise typer.Exit(1)

    port = _get_port()
    health = _wait_healthy(port)
    if health:
        process = _check_process_running(port)
        worker_info = f", {process['workers']} workers" if process["workers"] else ""
        console.print(
            f"[green]\u2713[/green] MCP Gateway running "
            f"({health.get('entities', '?')} entities{worker_info})"
        )
    else:
        console.print("[yellow]Service restarted but health check not responding yet.[/yellow]")
        console.print(f"Check logs: [cyan]sudo journalctl -u {SERVICE_NAME} --no-pager -n 20[/cyan]")


# =============================================================================
# Keys Management
# =============================================================================

keys_app = typer.Typer(help="Manage API keys for UAVCrew connections.")
app.add_typer(keys_app, name="keys")


def _get_all_keys(env_vars: dict) -> list[str]:
    """Get all configured API keys from env vars."""
    keys = []

    # Single key
    single = env_vars.get("MCP_API_KEY", "").strip()
    if single:
        keys.append(single)

    # Multiple keys
    multi = env_vars.get("MCP_API_KEYS", "").strip()
    if multi:
        for k in multi.split(","):
            k = k.strip()
            if k and k not in keys:
                keys.append(k)

    return keys


def _save_keys(env_path: Path, keys: list[str]) -> None:
    """Save keys back to .env file."""
    if not env_path.exists():
        console.print("[red]Error: .env file not found. Run 'uavcrew setup' first.[/red]")
        raise typer.Exit(1)

    # Read current file
    with open(env_path) as f:
        lines = f.readlines()

    # Update or add key lines
    new_lines = []
    found_api_key = False
    found_api_keys = False

    for line in lines:
        stripped = line.strip()
        if stripped.startswith("MCP_API_KEY="):
            # Keep first key in MCP_API_KEY for backwards compat
            if keys:
                new_lines.append(f"MCP_API_KEY={keys[0]}\n")
            else:
                new_lines.append("MCP_API_KEY=\n")
            found_api_key = True
        elif stripped.startswith("MCP_API_KEYS="):
            # Put additional keys in MCP_API_KEYS
            if len(keys) > 1:
                new_lines.append(f"MCP_API_KEYS={','.join(keys[1:])}\n")
            else:
                new_lines.append("MCP_API_KEYS=\n")
            found_api_keys = True
        else:
            new_lines.append(line)

    # Add lines if not found
    if not found_api_key:
        new_lines.append(f"\nMCP_API_KEY={keys[0] if keys else ''}\n")
    if not found_api_keys and len(keys) > 1:
        new_lines.append(f"MCP_API_KEYS={','.join(keys[1:])}\n")

    # Write back
    with open(env_path, "w") as f:
        f.writelines(new_lines)


def _mask_key(key: str) -> str:
    """Mask a key for display, showing first 8 and last 4 chars."""
    if len(key) <= 12:
        return key[:4] + "****"
    return key[:8] + "****" + key[-4:]


@keys_app.command("list")
def keys_list():
    """Show configured API keys."""
    env_path = Path.cwd() / ".env"

    if not env_path.exists():
        console.print("[red]No .env file found. Run 'uavcrew setup' first.[/red]")
        raise typer.Exit(1)

    env_vars = load_env_file(env_path)
    keys = _get_all_keys(env_vars)

    if not keys:
        console.print("[yellow]No API keys configured.[/yellow]")
        console.print("Add one with: [cyan]uavcrew keys add <token>[/cyan]")
        return

    console.print(f"\n[bold]Configured API Keys ({len(keys)}):[/bold]\n")

    table = Table()
    table.add_column("#", style="dim")
    table.add_column("Key (masked)", style="cyan")
    table.add_column("Source", style="dim")

    for i, key in enumerate(keys, 1):
        source = "MCP_API_KEY" if i == 1 else "MCP_API_KEYS"
        table.add_row(str(i), _mask_key(key), source)

    console.print(table)
    console.print("\n[dim]Keys are used to authenticate requests from UAVCrew instances.[/dim]")


@keys_app.command("add")
def keys_add(token: str = typer.Argument(..., help="API token from UAVCrew dashboard")):
    """Add an API key."""
    env_path = Path.cwd() / ".env"

    if not env_path.exists():
        console.print("[red]No .env file found. Run 'uavcrew setup' first.[/red]")
        raise typer.Exit(1)

    env_vars = load_env_file(env_path)
    keys = _get_all_keys(env_vars)

    # Check if already exists
    if token in keys:
        console.print("[yellow]This key is already configured.[/yellow]")
        return

    # Add key
    keys.append(token)
    _save_keys(env_path, keys)

    console.print(f"[green]\u2713[/green] Added key: {_mask_key(token)}")
    console.print(f"[dim]Total keys: {len(keys)}[/dim]")
    console.print("\n[yellow]Restart the server to apply:[/yellow]")
    console.print(f"  [cyan]sudo systemctl restart {SERVICE_NAME}[/cyan]")


@keys_app.command("remove")
def keys_remove(key_prefix: str = typer.Argument(..., help="Key or prefix to remove (first 8+ chars)")):
    """Remove an API key by prefix match."""
    env_path = Path.cwd() / ".env"

    if not env_path.exists():
        console.print("[red]No .env file found.[/red]")
        raise typer.Exit(1)

    env_vars = load_env_file(env_path)
    keys = _get_all_keys(env_vars)

    if not keys:
        console.print("[yellow]No keys configured.[/yellow]")
        return

    # Find matching key
    matches = [k for k in keys if k.startswith(key_prefix)]

    if not matches:
        console.print(f"[red]No key found matching '{key_prefix}'[/red]")
        console.print("Use [cyan]uavcrew keys list[/cyan] to see configured keys.")
        return

    if len(matches) > 1:
        console.print(f"[yellow]Multiple keys match '{key_prefix}':[/yellow]")
        for m in matches:
            console.print(f"  {_mask_key(m)}")
        console.print("Provide more characters to match exactly one key.")
        return

    # Remove the key
    key_to_remove = matches[0]
    keys.remove(key_to_remove)
    _save_keys(env_path, keys)

    console.print(f"[green]\u2713[/green] Removed key: {_mask_key(key_to_remove)}")
    console.print(f"[dim]Remaining keys: {len(keys)}[/dim]")

    if keys:
        console.print("\n[yellow]Restart the server to apply:[/yellow]")
        console.print(f"  [cyan]sudo systemctl restart {SERVICE_NAME}[/cyan]")
    else:
        console.print("\n[yellow]Warning: No keys remaining. Server will accept any request.[/yellow]")


@app.command()
def setup():
    """Interactive setup wizard for UAVCrew MCP Gateway."""
    console.print(
        Panel.fit(
            "[bold blue]UAVCrew MCP Gateway Setup[/bold blue]\n\n"
            "This wizard will configure your MCP gateway to connect with UAVCrew.ai.\n"
            "The gateway translates entity operations into client API calls.",
            border_style="blue",
        )
    )

    env_path = Path.cwd() / ".env"
    existing = {}

    # Load existing config if available
    if env_path.exists():
        existing = load_env_file(env_path)
        console.print("\n[yellow]Found existing .env file. Values will be used as defaults.[/yellow]")
        if not Confirm.ask("Continue with setup?", default=True):
            console.print("Setup cancelled.", style="yellow")
            raise typer.Exit(0)

    config = {}

    # =========================================================================
    # STEP 1: Server Identity & Access
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 1: Server Identity & Access[/bold cyan]")
    console.print("=" * 60)
    console.print(
        "\nThese settings define how UAVCrew.ai will connect to your MCP gateway."
    )

    # Server name
    console.print("\n[bold]Server Name[/bold]")
    console.print("  A friendly name to identify this server in the UAVCrew dashboard.")
    console.print("  Examples: 'NYC Operations MCP', 'Acme Corp Flight Data', 'Production MCP'")
    config["MCP_SERVER_NAME"] = Prompt.ask(
        "\n  Server name",
        default=existing.get("MCP_SERVER_NAME", "MCP Server"),
    )

    # Public URL
    console.print("\n[bold]Public URL[/bold]")
    console.print("  The HTTPS URL where UAVCrew.ai can reach this server.")
    console.print("  This is your domain with HTTPS, NOT the local port.")
    console.print("  Examples: 'https://mcp.yourcompany.com', 'https://uav-data.example.org'")
    console.print("\n  [dim]You'll set up the reverse proxy (Caddy/Nginx) in a later step.[/dim]")
    config["MCP_PUBLIC_URL"] = Prompt.ask(
        "\n  Public URL",
        default=existing.get("MCP_PUBLIC_URL", "https://mcp.example.com"),
    )

    # Local binding
    console.print("\n[bold]Local Server Binding[/bold]")
    console.print("  The MCP gateway listens locally on this host:port.")
    console.print("  Your reverse proxy (Caddy/Nginx) will forward HTTPS traffic here.")
    config["MCP_HOST"] = Prompt.ask(
        "  Listen address",
        default=existing.get("MCP_HOST", "127.0.0.1"),
    )
    config["MCP_PORT"] = Prompt.ask(
        "  Listen port",
        default=existing.get("MCP_PORT", "8200"),
    )

    # =========================================================================
    # STEP 2: Client API Configuration
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 2: Client API Configuration[/bold cyan]")
    console.print("=" * 60)
    console.print(
        "\nThe MCP gateway forwards requests to your client API.\n"
        "The manifest file defines which entities and actions are available."
    )

    # Manifest path
    console.print("\n[bold]Manifest File[/bold]")
    console.print("  Path to manifest.json that defines entities and API paths.")
    console.print("  See manifest.json.example for the reference format.")
    config["MCP_MANIFEST_PATH"] = Prompt.ask(
        "\n  Manifest path",
        default=existing.get("MCP_MANIFEST_PATH", "./manifest.json"),
    )

    # Validate manifest if it exists
    manifest_path = Path(config["MCP_MANIFEST_PATH"])
    if manifest_path.exists():
        try:
            from .manifest import load_manifest, get_entity_names
            manifest = load_manifest(str(manifest_path))
            entity_names = get_entity_names(manifest)
            console.print(f"  [green]\u2713[/green] Manifest valid ({len(entity_names)} entities: {', '.join(entity_names)})")
        except Exception as e:
            console.print(f"  [red]\u2717[/red] Manifest error: {e}")
            if not Confirm.ask("  Continue anyway?", default=False):
                raise typer.Exit(1)
    else:
        example_path = Path("manifest.json.example")
        if example_path.exists():
            import shutil
            shutil.copy(example_path, manifest_path)
            console.print(f"  [green]\u2713[/green] Copied manifest.json.example → {manifest_path}")
            console.print("  [dim]Edit manifest.json to customize entity paths for your API.[/dim]")
        else:
            console.print(f"  [yellow]![/yellow] Manifest not found at {config['MCP_MANIFEST_PATH']}")
            console.print("  [dim]Create a manifest.json before starting the server.[/dim]")

    # Client API base URL
    console.print("\n[bold]Client API Base URL[/bold]")
    console.print("  The base URL of the REST API that the gateway forwards requests to.")
    console.print("  Entity paths from manifest.json are appended to this URL.")
    console.print("  Examples: 'https://app.example.com/api/v1', 'http://localhost:8000/api/v1'")
    config["CLIENT_API_BASE_URL"] = Prompt.ask(
        "\n  Client API base URL",
        default=existing.get("CLIENT_API_BASE_URL", ""),
    )

    if config["CLIENT_API_BASE_URL"]:
        console.print(f"  [green]\u2713[/green] Base URL: {config['CLIENT_API_BASE_URL']}")
    else:
        console.print("  [yellow]![/yellow] No base URL provided - will use api_base_url from manifest.json")

    # =========================================================================
    # STEP 3: Client API Authentication
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 3: Client API Authentication[/bold cyan]")
    console.print("=" * 60)
    console.print(
        "\nThe gateway needs an API token (K4) to authenticate when calling your client API.\n"
        "This can be a single static key, or resolved dynamically per tenant."
    )

    # Detect existing auth config from manifest
    existing_auth_mode = "1"
    existing_token_env = "CLIENT_API_TOKEN"
    existing_resolver_path = "/internal/mcp/resolve-token"
    if manifest_path.exists():
        try:
            import json as _json
            with open(manifest_path) as _mf:
                _existing_manifest = _json.load(_mf)
            _existing_auth = _existing_manifest.get("auth", {})
            if _existing_auth.get("mode") == "dynamic":
                existing_auth_mode = "2"
                existing_resolver_path = _existing_auth.get("resolver_path", existing_resolver_path)
            else:
                existing_token_env = _existing_auth.get("token_env", existing_token_env)
        except Exception:
            pass

    console.print("\n[bold]How does the gateway authenticate to your client API?[/bold]")
    console.print("  1. Single tenant — one API key for all requests")
    console.print("  2. Multiple tenants — resolve API keys dynamically per tenant")

    auth_choice = Prompt.ask(
        "\n  Select option",
        choices=["1", "2"],
        default=existing_auth_mode,
    )

    auth_config = {}
    if auth_choice == "1":
        token_env = Prompt.ask(
            "  Env var name for API key",
            default=existing_token_env,
        )
        auth_config = {"mode": "static", "token_env": token_env}
        console.print(f"  [green]\u2713[/green] Static auth: set {token_env} in .env with your client API key")
    else:
        resolver_path = Prompt.ask(
            "  Resolver endpoint path",
            default=existing_resolver_path,
        )
        auth_config = {"mode": "dynamic", "resolver_path": resolver_path}
        console.print(f"  [green]\u2713[/green] Dynamic auth: gateway will call {{api_base_url}}{resolver_path}")
        console.print("  [dim]Your client API must expose this endpoint and validate T1 JWTs.[/dim]")

    # Write auth config to manifest
    if manifest_path.exists():
        try:
            import json as _json
            with open(manifest_path) as _mf:
                manifest_data = _json.load(_mf)
            manifest_data["auth"] = auth_config
            with open(manifest_path, "w") as _mf:
                _json.dump(manifest_data, _mf, indent=2)
                _mf.write("\n")
            console.print(f"  [green]\u2713[/green] Auth config saved to {manifest_path}")
        except Exception as e:
            console.print(f"  [yellow]![/yellow] Could not update manifest: {e}")
            console.print("  [dim]Add the auth section to manifest.json manually.[/dim]")
    else:
        console.print(f"  [yellow]![/yellow] Manifest not found — add auth config when you create it")

    # =========================================================================
    # Auto-detect K3 public key
    # =========================================================================
    # K3 ships with the MCP server in keys/k3_public.pem
    k3_path = Path.cwd() / "keys" / "k3_public.pem"
    if k3_path.exists():
        config["MCP_JWT_PUBLIC_KEY_PATH"] = str(k3_path)
        console.print(f"\n  [green]\u2713[/green] K3 public key: {k3_path}")
    elif existing.get("MCP_JWT_PUBLIC_KEY_PATH"):
        config["MCP_JWT_PUBLIC_KEY_PATH"] = existing["MCP_JWT_PUBLIC_KEY_PATH"]

    # =========================================================================
    # STEP 4: Save Configuration
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 4: Save Configuration[/bold cyan]")
    console.print("=" * 60)

    write_env_file(env_path, config)
    console.print(f"\n  [green]\u2713[/green] Configuration saved to {env_path}")

    # =========================================================================
    # STEP 5: Reverse Proxy Setup
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 5: Reverse Proxy Setup[/bold cyan]")
    console.print("=" * 60)
    console.print(
        "\nA reverse proxy handles HTTPS and forwards requests to the MCP gateway.\n"
        "This makes your server accessible at your public URL with SSL encryption."
    )

    console.print("\n[bold]What reverse proxy do you use?[/bold]")
    console.print("  1. Caddy [green](recommended - automatic HTTPS)[/green]")
    console.print("  2. Nginx")
    console.print("  3. Apache")
    console.print("  4. None / I'll configure it myself")

    proxy_choice = Prompt.ask(
        "\n  Select option",
        choices=["1", "2", "3", "4"],
        default="1",
    )

    # Extract domain from public URL
    domain = config["MCP_PUBLIC_URL"].replace("https://", "").replace("http://", "").rstrip("/")

    proxy_configs = {
        "1": ("caddy-mcp.conf", generate_caddy_config, "Add to /etc/caddy/Caddyfile"),
        "2": ("nginx-mcp.conf", generate_nginx_config, f"/etc/nginx/sites-available/{domain}"),
        "3": ("apache-mcp.conf", generate_apache_config, f"/etc/apache2/sites-available/{domain}.conf"),
    }

    if proxy_choice in proxy_configs:
        filename, generator, panel_title = proxy_configs[proxy_choice]
        config_file = Path(filename)

        proxy_config = generator(domain)

        if config_file.exists() and config_file.read_text().strip() == proxy_config.strip():
            console.print(f"\n  [green]\u2713[/green] {filename} already configured for {domain}")
        else:
            console.print(f"\n[bold]Configuration:[/bold]")
            console.print(Panel(proxy_config, title=panel_title))

            if proxy_choice == "1":
                console.print("\n[bold]To apply:[/bold]")
                console.print("  1. Add the above to your Caddyfile")
                console.print("  2. Run: [cyan]sudo systemctl reload caddy[/cyan]")
                console.print("\n  Caddy will automatically obtain and renew SSL certificates.")
            elif proxy_choice == "2":
                console.print("\n[bold]To apply:[/bold]")
                console.print(f"  1. Save to /etc/nginx/sites-available/{domain}")
                console.print(f"  2. Run: [cyan]sudo ln -s /etc/nginx/sites-available/{domain} /etc/nginx/sites-enabled/[/cyan]")
                console.print(f"  3. Get SSL cert: [cyan]sudo certbot --nginx -d {domain}[/cyan]")
                console.print("  4. Run: [cyan]sudo systemctl reload nginx[/cyan]")
            elif proxy_choice == "3":
                console.print("\n[bold]To apply:[/bold]")
                console.print("  1. Enable required modules: [cyan]sudo a2enmod proxy proxy_http ssl[/cyan]")
                console.print(f"  2. Save to /etc/apache2/sites-available/{domain}.conf")
                console.print(f"  3. Run: [cyan]sudo a2ensite {domain}[/cyan]")
                console.print(f"  4. Get SSL cert: [cyan]sudo certbot --apache -d {domain}[/cyan]")
                console.print("  5. Run: [cyan]sudo systemctl reload apache2[/cyan]")

            if Confirm.ask(f"\n  Save config to ./{filename}?", default=True):
                with open(filename, "w") as f:
                    f.write(proxy_config)
                console.print(f"  [green]\u2713[/green] Saved to ./{filename}")

    else:
        console.print("\n  Skipping reverse proxy configuration.")
        console.print(f"  Make sure to configure your proxy to forward {config['MCP_PUBLIC_URL']} to localhost:{config['MCP_PORT']}")

    # =========================================================================
    # STEP 6: Systemd Service
    # =========================================================================
    console.print("\n" + "=" * 60)
    console.print("[bold cyan]STEP 6: Systemd Service[/bold cyan]")
    console.print("=" * 60)
    console.print(
        "\nA systemd service keeps the MCP gateway running and starts it on boot."
    )

    service_file = Path(f"/etc/systemd/system/{SERVICE_NAME}.service")
    if service_file.exists():
        paths = detect_paths()
        expected = generate_systemd_unit(paths, env_path)
        try:
            installed = service_file.read_text()
        except PermissionError:
            proc = subprocess.run(
                ["sudo", "cat", str(service_file)],
                capture_output=True, text=True,
            )
            installed = proc.stdout

        if installed.strip() == expected.strip():
            console.print(f"\n  [green]\u2713[/green] Systemd service already installed and up to date")
        else:
            console.print(f"\n  [yellow]![/yellow] Systemd service exists but config has changed")
            if Confirm.ask("  Regenerate and reinstall?", default=True):
                _generate_systemd(env_path)
    else:
        if Confirm.ask("\n  Generate and install systemd service?", default=True):
            _generate_systemd(env_path)

    # =========================================================================
    # DONE
    # =========================================================================
    console.print("\n" + "=" * 60)

    # Count entities if manifest is available
    entity_info = ""
    manifest_path = Path(config["MCP_MANIFEST_PATH"])
    if manifest_path.exists():
        try:
            from .manifest import load_manifest, get_entity_names
            m = load_manifest(str(manifest_path))
            entity_info = f"\nEntities: {len(get_entity_names(m))} (from {config['MCP_MANIFEST_PATH']})"
        except Exception:
            pass

    # Auth-mode-specific instructions
    auth_mode_label = auth_config.get("mode", "static")
    if auth_mode_label == "static":
        token_env = auth_config.get("token_env", "CLIENT_API_TOKEN")
        auth_step = (
            f"2. Set your client API key in .env:\n"
            f"   [cyan]{token_env}=<your-api-key>[/cyan]\n"
        )
    else:
        resolver_path = auth_config.get("resolver_path", "/internal/mcp/resolve-token")
        auth_step = (
            f"2. Ensure your client API exposes the resolver:\n"
            f"   [cyan]POST {{api_base_url}}{resolver_path}[/cyan]\n"
            f"   The gateway calls this with T1 JWT to get K4 per tenant.\n"
        )

    console.print(
        Panel.fit(
            "[bold green]Setup Complete![/bold green]\n\n"
            f"Server:     {config['MCP_SERVER_NAME']}\n"
            f"URL:        {config['MCP_PUBLIC_URL']}\n"
            f"Local:      {config['MCP_HOST']}:{config['MCP_PORT']}\n"
            f"Auth mode:  {auth_mode_label}"
            f"{entity_info}\n\n"
            "[bold]Post-Setup Steps:[/bold]\n\n"
            "1. Start the gateway:\n"
            "   [cyan]uavcrew start[/cyan]\n\n"
            f"{auth_step}\n"
            "3. Register this server on UAVCrew.ai:\n"
            "   [link]https://www.uavcrew.ai/dashboard/mcp/[/link]\n"
            f"   Enter name: [cyan]{config['MCP_SERVER_NAME']}[/cyan]\n"
            f"   Enter URL:  [cyan]{config['MCP_PUBLIC_URL']}[/cyan]\n"
            "   Copy the connection token\n\n"
            "4. Add the connection token:\n"
            "   [cyan]uavcrew keys add <token-from-step-3>[/cyan]\n\n"
            "5. Restart to apply:\n"
            "   [cyan]uavcrew restart[/cyan]\n\n"
            "[bold]Commands:[/bold]\n"
            "  [cyan]uavcrew status[/cyan]    - Check health and configuration\n"
            "  [cyan]uavcrew start[/cyan]     - Start the service\n"
            "  [cyan]uavcrew restart[/cyan]   - Restart after config changes",
            border_style="green",
        )
    )


def _generate_systemd(env_path: Optional[Path] = None):
    """Internal systemd generation."""
    if env_path is None:
        env_path = Path.cwd() / ".env"

    paths = detect_paths()
    venv_bin = f"{paths['venv']}/bin" if paths["venv"] else "/usr/local/bin"

    # Show detected paths
    table = Table(title="Detected Configuration")
    table.add_column("Setting", style="cyan")
    table.add_column("Value", style="white")
    table.add_row("Working directory", str(paths["workdir"]))
    table.add_row("Gunicorn", f"{venv_bin}/gunicorn")
    table.add_row("User", paths["user"])
    if paths["venv"]:
        table.add_row("Virtual environment", str(paths["venv"]))
    table.add_row("Log directory", LOG_DIR)
    console.print(table)

    # Create log directory
    log_dir = Path(LOG_DIR)
    if not log_dir.exists():
        console.print(f"\n  Creating log directory: {LOG_DIR}")
        try:
            subprocess.run(
                ["sudo", "mkdir", "-p", LOG_DIR],
                check=True, capture_output=True,
            )
            subprocess.run(
                ["sudo", "chown", f"{paths['user']}:{paths['user']}", LOG_DIR],
                check=True, capture_output=True,
            )
            console.print(f"  [green]\u2713[/green] Log directory created")
        except subprocess.CalledProcessError:
            console.print(f"  [yellow]![/yellow] Could not create log directory")
            console.print(f"  Run manually: [cyan]sudo mkdir -p {LOG_DIR} && sudo chown {paths['user']}:{paths['user']} {LOG_DIR}[/cyan]")
    else:
        console.print(f"\n  [green]\u2713[/green] Log directory exists: {LOG_DIR}")

    # Generate unit file
    unit_content = generate_systemd_unit(paths, env_path)

    console.print("\n[bold]Generated unit file:[/bold]")
    console.print(Panel(unit_content, title="mcp-server.service"))

    # Save options
    console.print("\n[bold]Where to save?[/bold]")
    console.print("  1. Install to /etc/systemd/system/ [green](recommended)[/green]")
    console.print("  2. Save to current directory")
    console.print("  3. Don't save")

    action = Prompt.ask("\n  Select action", choices=["1", "2", "3"], default="1")

    if action == "1":
        output_path = Path("/etc/systemd/system/mcp-server.service")
        try:
            # Try direct write first (if running as root)
            with open(output_path, "w") as f:
                f.write(unit_content)
        except PermissionError:
            # Fall back to sudo
            console.print("  Requires sudo privileges...", style="yellow")
            proc = subprocess.run(
                ["sudo", "tee", str(output_path)],
                input=unit_content.encode(),
                capture_output=True,
            )
            if proc.returncode != 0:
                console.print("  [red]\u2717[/red] Failed to write systemd unit file", style="red")
                console.print("  Try option 2 to save locally, then install manually.")
                return

        console.print(f"  [green]\u2713[/green] Installed to {output_path}")

        # Reload systemd
        try:
            subprocess.run(["sudo", "systemctl", "daemon-reload"], check=True, capture_output=True)
            console.print("  [green]\u2713[/green] Reloaded systemd")
        except subprocess.CalledProcessError:
            console.print("  [yellow]![/yellow] Could not reload systemd")

        if Confirm.ask("\n  Enable service to start on boot?", default=True):
            try:
                subprocess.run(
                    ["sudo", "systemctl", "enable", "mcp-server"],
                    check=True,
                    capture_output=True,
                )
                console.print("  [green]\u2713[/green] Service enabled")
            except subprocess.CalledProcessError:
                console.print("  [yellow]![/yellow] Could not enable service")

        if Confirm.ask("\n  Restart service now?", default=True):
            try:
                subprocess.run(
                    ["sudo", "systemctl", "restart", SERVICE_NAME],
                    check=True,
                    capture_output=True,
                )
                console.print(f"  [green]\u2713[/green] Service restarted")
            except subprocess.CalledProcessError:
                console.print(f"  [yellow]![/yellow] Could not restart service")
                console.print(f"  Run manually: [cyan]sudo systemctl restart {SERVICE_NAME}[/cyan]")

    elif action == "2":
        output_path = Path.cwd() / "mcp-server.service"
        with open(output_path, "w") as f:
            f.write(unit_content)
        console.print(f"\n  [green]\u2713[/green] Saved to {output_path}")
        console.print("\n  [bold]To install manually:[/bold]")
        console.print(f"    sudo cp {output_path} /etc/systemd/system/")
        console.print("    sudo systemctl daemon-reload")
        console.print("    sudo systemctl enable --now mcp-server")

    else:
        console.print("\n  Skipped. Copy the unit file above manually if needed.")


@app.command("generate-systemd")
def generate_systemd():
    """Generate systemd unit file for the MCP Gateway."""
    console.print(
        Panel.fit(
            "[bold blue]UAVCrew MCP Gateway - Systemd Generator[/bold blue]",
            border_style="blue",
        )
    )
    _generate_systemd()


if __name__ == "__main__":
    app()
